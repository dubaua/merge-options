{"version":3,"file":"merge-options.min.js","sources":["../merge-options.js"],"sourcesContent":["function isObject(value) {\r\n  return value !== null && typeof value === 'object' && Array.isArray(value) === false;\r\n}\r\n\r\n/**\r\n * @typedef {Object} requiredArguments\r\n * @property {Object} options - user options needs validation before merge\r\n * @property {Object} defaults - default options object each contains initial value, validator and description\r\n * @property {Object} target - target object where merge will be applied\r\n * @property {String} [warnPreffix] - string before warning message, useful to pass name of tool\r\n * @property {String} [warnSuffix] - string after warning message, useful to pass link to documentation\r\n */\r\n\r\n/**\r\n * Merges given user options passed validation and defaults to target object\r\n * Shows warning if given option is invalid\r\n *\r\n * @param {...requiredArguments} config - confuguration object\r\n */\r\n\r\nfunction mergeOptions({ options = {}, defaults, target, warnPreffix = '', warnSuffix = '' }) {\r\n  // validating user input\r\n  if (!isObject(options)) {\r\n    throw new TypeError(`options is required and should be an object, got ${typeof options} ${options}.`);\r\n  }\r\n\r\n  if (!isObject(defaults)) {\r\n    throw new TypeError(`defaults is required and should be an object, got ${typeof defaults} ${defaults}.`);\r\n  }\r\n\r\n  Object.keys(defaults)\r\n    .map(key => defaults[key])\r\n    .forEach(option => {\r\n      if (!isObject(option)) {\r\n        throw new TypeError(`default option should be an object, got ${typeof option} ${option}.`);\r\n      }\r\n\r\n      if (!Object.prototype.hasOwnProperty.call(option, 'initial')) {\r\n        throw new TypeError(`default options should have initial value`);\r\n      }\r\n\r\n      if (!Object.prototype.hasOwnProperty.call(option, 'description')) {\r\n        throw new TypeError(`default options should have description`);\r\n      }\r\n\r\n      if (typeof option.description !== 'string') {\r\n        throw new TypeError(\r\n          `default option description should be a string, got ${typeof option.description} ${option.description}`\r\n        );\r\n      }\r\n\r\n      if (!Object.prototype.hasOwnProperty.call(option, 'validator')) {\r\n        throw new TypeError(`default options should have validator function`);\r\n      }\r\n\r\n      if (typeof option.validator !== 'function') {\r\n        throw new TypeError(\r\n          `default option validator should be a function, got ${typeof option.validator} ${option.validator}`\r\n        );\r\n      }\r\n    });\r\n\r\n  if (!isObject(target)) {\r\n    throw new TypeError(`target is required and should be an object, got ${typeof target} ${target}.`);\r\n  }\r\n\r\n  if (warnPreffix !== undefined && typeof warnPreffix !== 'string') {\r\n    throw new TypeError(`warnPreffix should be a string, got ${typeof warnPreffix} ${warnPreffix}.`);\r\n  }\r\n\r\n  if (warnSuffix !== undefined && typeof warnSuffix !== 'string') {\r\n    throw new TypeError(`warnSuffix should be a string, got ${typeof warnSuffix} ${warnSuffix}.`);\r\n  }\r\n\r\n  // iterate over defaults to merge only trusted options\r\n  for (const key in defaults) {\r\n    const { initial, description, validator } = defaults[key];\r\n    // assing initial value first\r\n    target[key] = initial;\r\n    // if this option passed\r\n    if (Object.prototype.hasOwnProperty.call(options, key)) {\r\n      const value = options[key];\r\n      // if option valid, reassign it\r\n      if (validator(value)) {\r\n        target[key] = value;\r\n      } else {\r\n        // otherwise print what's wrong ang give clues\r\n        console.warn(\r\n          `${warnPreffix}Expected ${key} is ${description}, got %c${typeof value}`,\r\n          'font-style: italic; text-transform: capitalize',\r\n          `${value}. Fallback to default value ${initial}.`,\r\n          warnSuffix\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default mergeOptions;\r\n"],"names":["isObject","value","Array","isArray","ref","options","TypeError","defaults","Object","keys","map","key","forEach","option","prototype","hasOwnProperty","call","description","validator","target","undefined","warnPreffix","warnSuffix","const","initial","console","warn"],"mappings":"aAAA,SAASA,EAASC,UACC,OAAVA,GAAmC,iBAAVA,IAA+C,IAAzBC,MAAMC,QAAQF,kBAmBtE,SAAsBG,kCAAY,+DAAoC,yCAAiB,KAEhFJ,EAASK,SACN,IAAIC,qEAAqED,MAAWA,WAGvFL,EAASO,SACN,IAAID,sEAAsEC,MAAYA,UAG9FC,OAAOC,KAAKF,GACTG,aAAIC,UAAOJ,EAASI,KACpBC,iBAAQC,OACFb,EAASa,SACN,IAAIP,4DAA4DO,MAAUA,WAG7EL,OAAOM,UAAUC,eAAeC,KAAKH,EAAQ,iBAC1C,IAAIP,UAAW,iDAGlBE,OAAOM,UAAUC,eAAeC,KAAKH,EAAQ,qBAC1C,IAAIP,UAAW,8CAGW,iBAAvBO,EAAOI,kBACV,IAAIX,uEACqDO,EAAOI,gBAAeJ,EAAmB,iBAIrGL,OAAOM,UAAUC,eAAeC,KAAKH,EAAQ,mBAC1C,IAAIP,UAAW,qDAGS,mBAArBO,EAAOK,gBACV,IAAIZ,uEACqDO,EAAOK,cAAaL,EAAiB,cAKrGb,EAASmB,SACN,IAAIb,oEAAoEa,MAAUA,eAGtEC,IAAhBC,GAAoD,iBAAhBA,QAChC,IAAIf,wDAAwDe,MAAeA,eAGhED,IAAfE,GAAkD,iBAAfA,QAC/B,IAAIhB,uDAAuDgB,MAAcA,WAI5EC,IAAMZ,KAAOJ,EAAU,OACkBA,EAASI,gDAErDQ,EAAOR,GAAOa,EAEVhB,OAAOM,UAAUC,eAAeC,KAAKX,EAASM,GAAM,KAChDV,EAAQI,EAAQM,GAElBO,EAAUjB,GACZkB,EAAOR,GAAOV,EAGdwB,QAAQC,KACHL,cAAuBV,SAAUM,oBAA6BhB,EACjE,iDACGA,iCAAoCuB,MACvCF"}